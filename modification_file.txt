MMM replace_function_class MMM
code_mod_defs.py
@@@@@@
GitRollbackManager.__init__
@@@@@@
def __init__(self, rollback_file='.modification_rollback.json'):
    self.rollback_file = rollback_file
    self.rollback_data = {}
    self.tracked_files = set()

MMM replace_function_class MMM
code_mod_defs.py
@@@@@@
GitRollbackManager.track_file
@@@@@@
def track_file(self, file_path):
    """Track a file for inclusion in git commits"""
    self.tracked_files.add(file_path)

MMM replace_function_class MMM
code_mod_defs.py
@@@@@@
GitRollbackManager.create_rollback_point
@@@@@@
def create_rollback_point(self, message=None, force_commit=False):
    """
    Create a git commit as a rollback point
    
    Args:
        message: Commit message (auto-generated if None)
        force_commit: If True, commit even if no changes exist
        
    Returns:
        dict: Rollback information including commit hash, branch, timestamp
    """
    if not self.is_git_repo():
        logging.warning("Not in a git repository - rollback not available")
        return None
    
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    if message is None:
        message = f"Pre-modification snapshot {timestamp}"
    
    current_commit = self.get_current_commit()
    current_branch = self.get_current_branch()
    
    try:
        # Add only tracked files to staging
        if self.tracked_files:
            for file_path in self.tracked_files:
                if os.path.exists(file_path):
                    subprocess.run(['git', 'add', file_path], check=True, capture_output=True)
                else:
                    # File was deleted, add it for removal
                    subprocess.run(['git', 'add', file_path], check=True, capture_output=True)
        
        # Check if there's anything to commit
        if not self.has_uncommitted_changes() and not force_commit:
            logging.info("No changes to commit, using current HEAD as rollback point")
            rollback_info = {
                'commit_hash': current_commit,
                'branch': current_branch,
                'timestamp': timestamp,
                'message': f"Rollback point (no changes): {message}",
                'was_clean': True
            }
        else:
            # Create commit
            subprocess.run(['git', 'commit', '-m', message], 
                         check=True, capture_output=True)
            new_commit = self.get_current_commit()
            
            rollback_info = {
                'commit_hash': new_commit,
                'branch': current_branch,
                'timestamp': timestamp,
                'message': message,
                'was_clean': False
            }
        
        # Save rollback info to file
        self.rollback_data = rollback_info
        self._save_rollback_data()
        
        logging.info(f"Created rollback point: {rollback_info['commit_hash']}")
        return rollback_info
        
    except subprocess.CalledProcessError as e:
        logging.error(f"Could not create git commit: {e}")
        return None

MMM replace_function_class MMM
code_mod_defs.py
@@@@@@
replace_function_class
@@@@@@
def replace_function_class(file_path, target_path, new_code):
    """
    Replace a function or class in a file with new code using lexical chain support.
    If the target doesn't exist, insert it in the appropriate location.
    
    Args:
        file_path: Path to the Python file
        target_path: Target path like 'function_name' or 'ClassName.method_name'
        new_code: New function/class code to replace with
    """
    with open(file_path, 'r') as f:
        content = f.read()
    
    target_name, lexical_chain = parse_lexical_chain(target_path)
    
    # Try replacement first
    new_content = replace_block(content, new_code, target_name=target_name, lexical_chain=lexical_chain)
    
    # Check if replacement actually happened by comparing content
    if new_content == content:
        # Target not found, insert instead
        new_content = insert_block(content, new_code, target_name=target_name, lexical_chain=lexical_chain)

    with open(file_path, 'w') as f:
        f.write(new_content)
    
    # Track file for git operations
    if hasattr(replace_function_class, '_rollback_manager'):
        replace_function_class._rollback_manager.track_file(file_path)
    
    logging.debug(f"Modified {target_path} in {file_path}")

MMM replace_function_class MMM
code_mod_defs.py
@@@@@@
search_replace_line
@@@@@@
def search_replace_line(file_path, search_text, replacement_text):
    """Search for a line and replace it"""
    with open(file_path, 'r') as f:
        lines = f.readlines()
    
    found = False
    for i, line in enumerate(lines):
        if search_text in line:
            lines[i] = replacement_text + '\n' if not replacement_text.endswith('\n') else replacement_text
            found = True
            break
    
    if not found:
        raise ValueError(f"Search text '{search_text}' not found in {file_path}")
    
    with open(file_path, 'w') as f:
        f.writelines(lines)
    
    # Track file for git operations
    if hasattr(search_replace_line, '_rollback_manager'):
        search_replace_line._rollback_manager.track_file(file_path)
    
    logging.debug(f"Replaced line containing '{search_text}' in {file_path}")

MMM replace_function_class MMM
code_mod_defs.py
@@@@@@
move_file
@@@@@@
def move_file(src, dst):
    """Move/rename file or directory"""
    # Track both source and destination for git operations
    if hasattr(move_file, '_rollback_manager'):
        move_file._rollback_manager.track_file(src)
        move_file._rollback_manager.track_file(dst)
    
    shutil.move(src, dst)
    logging.debug(f"Moved {src} to {dst}")

MMM replace_function_class MMM
code_mod_defs.py
@@@@@@
remove_file
@@@@@@
def remove_file(path, recursive=False):
    """Remove file or directory"""
    # Track file for git operations before removal
    if hasattr(remove_file, '_rollback_manager'):
        remove_file._rollback_manager.track_file(path)
    
    if recursive and os.path.isdir(path):
        shutil.rmtree(path)
        logging.debug(f"Removed directory {path} recursively")
    elif os.path.isfile(path):
        os.remove(path)
        logging.debug(f"Removed file {path}")
    elif os.path.isdir(path):
        os.rmdir(path)
        logging.debug(f"Removed empty directory {path}")
    else:
        raise FileNotFoundError(f"Path {path} does not exist")

MMM replace_function_class MMM
code_mod_defs.py
@@@@@@
create_file
@@@@@@
def create_file(file_path, file_content, make_executable=True):
    """Create a file
    
    Args:
        file_path: Path where script should be created
        file_content: Content of the script
        make_executable: If True, set executable permissions (Unix/Linux/Mac)
    """
    import stat
    
    with open(file_path, 'w') as f:
        f.write(file_content)
    
    if make_executable:
        # Add executable permissions for owner, group, and others
        current_permissions = os.stat(file_path).st_mode
        os.chmod(file_path, current_permissions | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)
    
    # Track file for git operations
    if hasattr(create_file, '_rollback_manager'):
        create_file._rollback_manager.track_file(file_path)
    
    logging.debug(f"Created {'executable script' if make_executable else 'file'} {file_path}")

MMM replace_function_class MMM
code_mod_defs.py
@@@@@@
apply_modification_set
@@@@@@
def apply_modification_set(modifications, auto_rollback_on_failure=True):
    """
    Apply a set of modifications with rollback support
    
    Args:
        modifications: List of (function, args, kwargs) tuples
        auto_rollback_on_failure: If True, automatically rollback on any failure
        
    Returns:
        GitRollbackManager: Manager instance for manual rollback operations
    """
    rollback_manager = GitRollbackManager()
    
    # Set rollback manager on modification functions
    replace_function_class._rollback_manager = rollback_manager
    search_replace_line._rollback_manager = rollback_manager
    move_file._rollback_manager = rollback_manager
    remove_file._rollback_manager = rollback_manager
    create_file._rollback_manager = rollback_manager
    
    # Create rollback point
    rollback_info = rollback_manager.create_rollback_point("Before LLM modifications")
    
    if not rollback_info:
        logging.warning("Proceeding without git rollback capability")
    
    try:
        # Apply all modifications
        for func, args, kwargs in modifications:
            func(*args, **kwargs)
        
        # Create final commit with tracked files
        if rollback_manager.tracked_files:
            rollback_manager.create_rollback_point("After LLM modifications", force_commit=True)
        
        logging.info("All modifications completed successfully")
        
        if rollback_info:
            rollback_manager.show_rollback_options()
        
        return rollback_manager
        
    except Exception as e:
        logging.error(f"Modifications failed: {e}")
        
        if auto_rollback_on_failure and rollback_info:
            logging.info("Auto-rolling back due to failure...")
            rollback_manager.hard_rollback()
        elif rollback_info:
            logging.info("Manual rollback available - use returned manager")
            rollback_manager.show_rollback_options()
        
        raise
    finally:
        # Clean up rollback manager references
        if hasattr(replace_function_class, '_rollback_manager'):
            del replace_function_class._rollback_manager
        if hasattr(search_replace_line, '_rollback_manager'):
            del search_replace_line._rollback_manager
        if hasattr(move_file, '_rollback_manager'):
            del move_file._rollback_manager
        if hasattr(remove_file, '_rollback_manager'):
            del remove_file._rollback_manager
        if hasattr(create_file, '_rollback_manager'):
            del create_file._rollback_manager